## Android应用分身


现在市面流程应用分身的机制分为2类：

* 基于Android虚拟技术 如VirtualApp

  VirtualApp
     是一款运行于Android系统的沙盒产品，可以理解为轻量级的“Android虚拟机”。其产品形态为高可扩展，可定制的集成SDK，您可以基于VA或者使用VA定制开发各种看似不可能完成的项目。VA目前被广泛应用于插件化开发、无感知热更新、云控自动化、多开、手游租号、手游手柄免激活、区块链、移动办公安全、军队政府保密、手机模拟信息、脚本自动化、自动化测试等技术领域

```
    克隆能力
       可以克隆外部系统中已经安装的App，并在内部运行，互不干扰。典型应用场景为App双开。

    免安装能力
      除了克隆已安装之外，VA可以直接在内部安装(外部无感知)apk，并在内部直接运行。典型应用场景为插件化，独立应用市场等。

    多开能力
      VA不仅可以“双开”，独特的多用户模式支持用户在内部无限多开同一个App。

    内外隔离能力
      VA是一个标准的沙盒，或者说“虚拟机”，提供了一整套内部与外部的隔离机制，包括但不限于(文件隔离/组件隔离/进程通讯隔离)，简单的说VA内部就是一个“完全独立的空间”。在此基础之上，稍作定制即可实现一部手机上的“虚拟手机”。当然您也可以发挥想象，定制成应用于数据加密，数据隔离，隐私保护，企业管理的应用系统。

    对于内部App的完全控制能力
      VA对于内部的App具有完全的监控和控制能力，这点在未Root的外部环境中是绝对无法实现的
```


        https://github.com/asLody/VirtualApp


* 基于Android原生UserManager多用户机制

    华为,oppo  xiami，也是使用的原生的多用户机制，但原生的多用户从部分逻辑到界面,都不满足双开的需求, 需要做不少的定制。



我们同样采用原生的多用户机制下的子帐号功能实现应用双开

## Code 修改

* 1:在当前用户下面创建子用户

```
  public void openSonSpace() {
        mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);

        // step 1 : call UMS.createProfileForUser() to create Managed Profile User
        UserHandle userHandle = android.os.Process.myUserHandle();

        mShadowSpaceUserInfo = mUserManager.createProfileForUser(UserManager.SHADOW_SPACE_USER_NAME,
                UserManager.USER_TYPE_PROFILE_MANAGED,
                FLAG_MANAGED_PROFILE,
                userHandle.getIdentifier()
                );

        // step 2 call AMS.startUserInBackground() to start the new user.
        int userId = getUserIdFromUserInfo(mShadowSpaceUserInfo);
        try{
          ActivityManager.getService().startUserInBackground(userId);
        } catch (
          RemoteException e) {
              Slog.w(TAG, "could not start pre-created user " + userId, e);
        }

        Log.d(TAG, "startUserInBackground() userId = " + userId + " | isOk = ");

    }

```

* 2：固定子用户的用户ID，供后面分配特定权限

   frameworks/base/services/core/java/com/android/server/pm/UserManagerService.java

```
  private UserInfo createUserInternalUncheckedNoTracing(@Nullable String name,

      //hzy_user
      if ((flags & UserInfo.FLAG_CUSTOM_PROFILE) != 0) {
          userId = UserManager.SHADOW_SPACE_USER_ID;
      }else {
          userId = getNextAvailableId();
      }
      Environment.getUserSystemDirectory(userId).mkdirs();
   }

```
     并确定那些系统服务必须，并安装.

```
  static {
      mBaseAppforShadowUser.add("android");
      mBaseAppforShadowUser.add("com.android.printspooler");
      mBaseAppforShadowUser.add("com.google.android.gms");
      mBaseAppforShadowUser.add("com.google.android.gsf");
      mBaseAppforShadowUser.add("com.android.packageinstaller");
      mBaseAppforShadowUser.add("com.android.keychain");
      mBaseAppforShadowUser.add("com.android.gallery3d");
      mBaseAppforShadowUser.add("com.google.android.packageinstaller");
      mBaseAppforShadowUser.add("com.android.webview");
      mBaseAppforShadowUser.add("com.android.inputmethod.latin");
      mBaseAppforShadowUser.add("com.android.permissioncontroller");
      mBaseAppforShadowUser.add("com.android.externalstorage");
      mBaseAppforShadowUser.add("com.android.providers.media");
      mBaseAppforShadowUser.add("com.android.providers.media.module");
      mBaseAppforShadowUser.add("com.android.certinstaller");
      mBaseAppforShadowUser.add("com.android.settings");
      mBaseAppforShadowUser.add("com.android.providers.telephony");
      mBaseAppforShadowUser.add("com.android.providers.calendar");
      mBaseAppforShadowUser.add("com.android.htmlviewer");
      mBaseAppforShadowUser.add("com.android.companiondevicemanager");
      mBaseAppforShadowUser.add("com.android.mms.service");
      ...


      if ((flags & UserInfo.FLAG_CUSTOM_PROFILE) != 0) {
           mBaseAppforShadowUser.add("packageName");
           mPm.createNewUser(userId, mBaseAppforShadowUser, disallowedPackages);
       }else{
           mPm.createNewUser(userId, userTypeInstallablePackages, disallowedPackages);
       }

```


* 3、修改新创建子帐号SHADOW_SPACE_USER_ID 的ContentProvider为主帐号共用


  >frameworks/base/core/java/android/app/ActivityThread.java

```

   public final IContentProvider acquireProvider(
        Context c, String auth, int userId, boolean stable) {

    if(userId == UserManager.SHADOW_SPACE_USER_ID &&
            ("packageName".equals(packages[0])||
                    "com.android.gallery3d".equals(packages[0])  )){
        Slog.e(TAG, "hzy acquireProvider change the user to 0 from " + userId);
        userId = 0;
    }

    final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);
    if (provider != null) {
        return provider;
    }

```


    frameworks/base/services/core/java/com/android/server/content/ContentService.java
```
  @Override
  public void registerContentObserver(Uri uri, boolean notifyForDescendants,
          IContentObserver observer, int userHandle, int targetSdkVersion) {
      if (observer == null || uri == null) {
          throw new IllegalArgumentException("You must pass a valid uri and observer");
      }

      final int uid = Binder.getCallingUid();
      final int pid = Binder.getCallingPid();

      //hzy_user

      String[] packages = mContext.getPackageManager().getPackagesForUid(uid);

      if(userHandle == UserManager.SHADOW_SPACE_USER_ID){
          userHandle = 0 ;
      }else {
          userHandle = handleIncomingUser(uri, pid, uid,
                  Intent.FLAG_GRANT_READ_URI_PERMISSION, true, userHandle);
      }

  }
```

* 4、解决用户交叉访问权限问题

  frameworks/base/core/java/android/content/pm/parsing/ParsingPackageUtils.java

```
  private ParseResult<ParsingPackage> parseBaseApk(ParseInput input, String apkPath,
          String codePath, Resources res, XmlResourceParser parser, int flags)
          throws XmlPullParserException, IOException, PackageParserException {
          ...
          final ParseResult<ParsingPackage> result =
          parseBaseApkTags(input, pkg, manifestArray, res, parser, flags);
        if (result.isError()) {
            return result;
        }
      //hzy_user
      if("packageName".equals(pkg.getPackageName())) {

          if (!pkg.getRequestedPermissions().contains(INTERACT_ACROSS_USERS_FULL_PERMISSION)) {
              pkg.addRequestedPermission(INTERACT_ACROSS_USERS_FULL_PERMISSION.intern());
          }
          if (!pkg.getRequestedPermissions().contains(INTERACT_ACROSS_USERS_PERMISSION)) {
              pkg.addRequestedPermission(INTERACT_ACROSS_USERS_PERMISSION.intern());

          }
      }

      ...
  }

```

      frameworks/base/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
```
  private boolean grantSignaturePermission(String perm, AndroidPackage pkg,
          PackageSetting pkgSetting, BasePermission bp, PermissionsState origPermissions) {

          ...
          if (allowed && privilegedPermission &&
            !vendorPrivilegedPermission && pkg.isVendor()) {
                Slog.w(TAG, "Permission " + perm + " cannot be granted to privileged vendor apk "
                 + pkg.getPackageName()
                 + " because it isn't a 'vendorPrivileged' permission.");
                allowed = false;
              }
            }
          }
          if (!allowed) {

             //hzy_user
             if("packageName".equals(pkg.getPackageName()))) {
                 if(perm.equals(ParsingPackageUtils.INTERACT_ACROSS_USERS_FULL_PERMISSION) ||
                         perm.equals(ParsingPackageUtils.INTERACT_ACROSS_USERS_PERMISSION)){
                      allowed =true;
                 }
             }
          }
          ...
  }

```
* 5：解决子帐号访问帐号ContentProvider权限

    frameworks/base/core/java/android/content/ContentProvider.java

  ```
  protected int enforceReadPermissionInner(Uri uri, String callingPkg,
        @Nullable String attributionTag, IBinder callerToken) throws SecurityException {
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    int strongestMode = MODE_ALLOWED;

    if (UserHandle.isSameApp(uid, mMyUid)) {
      return MODE_ALLOWED;
    }

    //hzy_user_v
    if ( UserHandle.getUserId(uid) == UserManager.SHADOW_SPACE_USER_ID){

       return MODE_ALLOWED;
    }
    ....

  }

  ```

  ```
  @VisibleForTesting
   public Uri validateIncomingUri(Uri uri) throws SecurityException {
       String auth = uri.getAuthority();
       if (!mSingleUser) {
           int userId = getUserIdFromAuthority(auth, UserHandle.USER_CURRENT);
           if(userId == UserManager.SHADOW_SPACE_USER_ID ){ // hzy_user
               Log.w(TAG, "validateIncomingUri skip the usr check for " + UserManager.SHADOW_SPACE_USER_ID );
           }else if (userId != UserHandle.USER_CURRENT && userId != mContext.getUserId()) {
               throw new SecurityException("trying to query a ContentProvider in user "
                       + mContext.getUserId() + " with a uri belonging to user " + userId);
           }
       }
       validateIncomingAuthority(auth);

      ...
   }
  ```

* 6.试图解决访问主用户多媒体夹/storage/emulated/0/问题
   以图库为例错误如下
   ```
  01-13 15:33:33.366  4127  4195 W LocalImage: failed to find file to read thumbnail: /storage/emulated/0/DCIM/Camera/IMG_20210113_101232.jpg
  01-13 15:33:33.368  4127  4195 W DecodeUtils: java.io.FileNotFoundException: /storage/emulated/0/DCIM/Camera/IMG_20210113_101232.jpg: open failed: EPERM (Operation not permitted)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at libcore.io.IoBridge.open(IoBridge.java:492)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at java.io.FileInputStream.<init>(FileInputStream.java:160)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at java.io.FileInputStream.<init>(FileInputStream.java:115)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at com.android.gallery3d.data.DecodeUtils.decodeThumbnail(DecodeUtils.java:103)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at com.android.gallery3d.data.LocalImage$LocalImageRequest.onDecodeOriginal(LocalImage.java:214)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at com.android.gallery3d.data.ImageCacheRequest.run(ImageCacheRequest.java:79)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at com.android.gallery3d.data.ImageCacheRequest.run(ImageCacheRequest.java:28)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at com.android.gallery3d.util.ThreadPool$Worker.run(ThreadPool.java:133)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at java.lang.Thread.run(Thread.java:923)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at com.android.gallery3d.util.PriorityThreadFactory$1.run(PriorityThreadFactory.java:44)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: Caused by: android.system.ErrnoException: open failed: EPERM (Operation not permitted)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at libcore.io.Linux.open(Native Method)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at libcore.io.ForwardingOs.open(ForwardingOs.java:166)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at libcore.io.BlockGuardOs.open(BlockGuardOs.java:254)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at libcore.io.ForwardingOs.open(ForwardingOs.java:166)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at android.app.ActivityThread$AndroidOs.open(ActivityThread.java:7563)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	at libcore.io.IoBridge.open(IoBridge.java:478)
  01-13 15:33:33.368  4127  4195 W DecodeUtils: 	... 11 more

   ```

  6.1  关掉selinux 权限检测，问题还是存在，排除selinux影响。

   ```
   adb shell setenforce 0

   ```

  6.2 Linux DAC权限排查


   查看/storage/emulated/0文件夹， 用户root和everybody用户组都具有rw权限如下

  ![](./image/2021-01-1315-38-53.png)

  添加图库everybody用户组

  frameworks/base/data/etc/platform.xml
  ```
  <!--   hzy_user-->
    <permission name="android.permission.INTERACT_ACROSS_USERS_FULL">
        <group gid="everybody" />
    </permission>

    <permission name="android.permission.INTERACT_ACROSS_USERS">
        <group gid="everybody" />
    </permission>
  ```

  生效之后,还是不能访问，现在Kernel由google提供，日志偏少,还在继续排查原因。

  ![](./image/2021-01-1315-57-03.png)

  7.键盘共享问题

   现在子用户无法访问，主用户的键盘，需要在子用户下面安装单独的键盘。这样存在用户体验不一致问题，需要后面解决。



8 .


frameworks/base/core/jni/com_android_internal_os_Zygote.cpp
在app启动的时候把/mnt/pass_through/9876 直接mount在在 storage 下面

```
// storage for the given user.
static void MountEmulatedStorage(uid_t uid, jint mount_mode,
        bool force_mount_namespace,
        fail_fn_t fail_fn) {
  // See storage config details at http://source.android.com/tech/storage/
  ATRACE_CALL();
  if(user_id == 9876){
     mount_mode = MOUNT_EXTERNAL_PASS_THROUGH;
  }
```

问题gallery可以看到小图,但打不开,camera 现实sdcard没有mount


9.
ContentService.java

public void registerContentObserver(Uri uri, boolean notifyForDescendants,
        IContentObserver observer, int userHandle, int targetSdkVersion) {
    if (observer == null || uri == null) {
        throw new IllegalArgumentException("You must pass a valid uri and observer");
    }

    final int uid = Binder.getCallingUid();
    final int pid = Binder.getCallingPid();
    //hzy_user

    String[] packages = mContext.getPackageManager().getPackagesForUid(uid);

    if(userHandle == UserManager.SHADOW_SPACE_USER_ID &&
            ("com.tencent.mobileqq".equals(packages[0]) || "com.android.gallery3d".equals(packages[0])) ){
        Slog.d(TAG, " 9876 packages= " + packages[0]  + " hzy registerContentObserver userHandle " + userHandle  + " uri = " +uri);
        userHandle = 0 ;
    } else {
        userHandle = handleIncomingUser(uri, pid, uid,
                Intent.FLAG_GRANT_READ_URI_PERMISSION, true, userHandle);
    }


10.EmulatedVolume.cpp


```
status_t MountUserFuse(userid_t user_id, const std::string& absolute_lower_path,
                       const std::string& relative_upper_path, android::base::unique_fd* fuse_fd) {
    std::string pre_fuse_path(StringPrintf("/mnt/user/%d", user_id));
    std::string fuse_path(
            StringPrintf("%s/%s", pre_fuse_path.c_str(), relative_upper_path.c_str()));

    std::string pre_pass_through_path(StringPrintf("/mnt/pass_through/%d", user_id));
    std::string pass_through_path(
            StringPrintf("%s/%s", pre_pass_through_path.c_str(), relative_upper_path.c_str()));


    std::string pre_pass_through_path_v(StringPrintf("/mnt/pass_through/%d", 0));
    std::string pass_through_path_v(
        StringPrintf("%s/%s", pre_pass_through_path_v.c_str(), relative_upper_path.c_str()));

    // Ensure that /mnt/user is 0700. With FUSE, apps don't need access to /mnt/user paths directly.
    // Without FUSE however, apps need /mnt/user access so /mnt/user in init.rc is 0755 until here
    auto result = PrepareDir("/mnt/user", 0777, AID_ROOT, AID_MEDIA_RW);
    if (result != android::OK) {
        PLOG(ERROR) << "Failed to prepare directory /mnt/user";
        return -1;
    }
  // 准备 fuse目录           /mnt/user/0 和 /mnt/user/0/emulated
   //  准备 pass_through_path  /mnt/pass_through/0 和 /mnt/pass_through/0/emulated .


     LOG(INFO) << "hzy_vold Bind mounting user_id = " << user_id << " pre_fuse_path  =" << pre_fuse_path;
     LOG(INFO) << "hzy_vold Bind mounting user_id = " << user_id << " fuse_path  =" << fuse_path;

//hzy_vold  pre_fuse_path  =/mnt/user/0
//fuse_path  =/mnt/user/0/emulated

     LOG(INFO) << "hzy_vold Bind mounting user_id = " << user_id << " pre_pass_through_path  =" << pre_pass_through_path;
     LOG(INFO) << "hzy_vold Bind mounting user_id = " << user_id << " pass_through_path  =" << pass_through_path;

    // Shell is neither AID_ROOT nor AID_EVERYBODY. Since it equally needs 'execute' access to
    // /mnt/user/0 to 'adb shell ls /sdcard' for instance, we set the uid bit of /mnt/user/0 to
    // AID_SHELL. This gives shell access along with apps running as group everybody (user 0 apps)
    // These bits should be consistent with what is set in zygote in
    // com_android_internal_os_Zygote#MountEmulatedStorage on volume bind mount during app fork
    result = PrepareDir(pre_fuse_path, 0777, user_id ? AID_ROOT : AID_SHELL,
                             multiuser_get_uid(user_id, AID_EVERYBODY));
    if (result != android::OK) {
        PLOG(ERROR) << "Failed to prepare directory " << pre_fuse_path;
        return -1;
    }

    result = PrepareDir(fuse_path, 0700, AID_ROOT, AID_ROOT);
    if (result != android::OK) {
        PLOG(ERROR) << "Failed to prepare directory " << fuse_path;
        return -1;
    }
//  准备 pass_through_path  /mnt/pass_through/0 和 /mnt/pass_through/0/emulated .
    result = PrepareDir(pre_pass_through_path, 0777, AID_ROOT, AID_MEDIA_RW);
    if (result != android::OK) {
        PLOG(ERROR) << "Failed to prepare directory " << pre_pass_through_path;
        return -1;
    }

    result = PrepareDir(pass_through_path, 0777, AID_ROOT, AID_MEDIA_RW);
    if (result != android::OK) {
        PLOG(ERROR) << "Failed to prepare directory " << pass_through_path;
        return -1;
    }

    if (relative_upper_path == "emulated") {
        std::string linkpath(StringPrintf("/mnt/user/%d/self", user_id));
        result = PrepareDir(linkpath, 0755, AID_ROOT, AID_ROOT);
        if (result != android::OK) {
            PLOG(ERROR) << "Failed to prepare directory " << linkpath;
            return -1;
        }
        linkpath += "/primary";
        Symlink("/storage/emulated/" + std::to_string(user_id), linkpath);

        std::string pass_through_linkpath(StringPrintf("/mnt/pass_through/%d/self", user_id));
        result = PrepareDir(pass_through_linkpath, 0710, AID_ROOT, AID_MEDIA_RW);
        if (result != android::OK) {
            PLOG(ERROR) << "Failed to prepare directory " << pass_through_linkpath;
            return -1;
        }
        pass_through_linkpath += "/primary";
        Symlink("/storage/emulated/" + std::to_string(user_id), pass_through_linkpath);
    }

    // Open fuse fd.
    fuse_fd->reset(open("/dev/fuse", O_RDWR | O_CLOEXEC));
    if (fuse_fd->get() == -1) {
        PLOG(ERROR) << "Failed to open /dev/fuse";
        return -1;
    }

    // Note: leaving out default_permissions since we don't want kernel to do lower filesystem
    // permission checks before routing to FUSE daemon.
    const auto opts = StringPrintf(
        "fd=%i,"
        "rootmode=40000,"
        "allow_other,"
        "user_id=0,group_id=0,",
        fuse_fd->get());

   LOG(INFO) << "hzy_vold Bind mounting ufuse_path.c_str()  " << fuse_path.c_str() ;
   LOG(INFO) << "hzy_vold Bind mounting opt   " << opts.c_str() ;

    result = TEMP_FAILURE_RETRY(mount("/dev/fuse", fuse_path.c_str(), "fuse",
                                      MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_NOATIME | MS_LAZYTIME,
                                      opts.c_str()));
    if (result != 0) {
        PLOG(ERROR) << "Failed to mount " << fuse_path;
        return -errno;
    }

    if (IsSdcardfsUsed()) {
        std::string sdcardfs_path(
                StringPrintf("/mnt/runtime/full/%s", relative_upper_path.c_str()));
        LOG(INFO) << "Bind mounting 123 " << sdcardfs_path << " to " << pass_through_path;

        return BindMount(sdcardfs_path, pass_through_path);
    } else {
        LOG(INFO) << "Bind mounting " << absolute_lower_path << " to " << pass_through_path;
          return BindMount(absolute_lower_path, pass_through_path);
    }
}

```


10
```
status_t EmulatedVolume::mountFuseBindMounts() {
    std::string androidSource;
    std::string label = getLabel();
    int userId = getMountUserId();
    std::list<std::string> pathsToUnmount;

    auto unmounter = [&]() {
        LOG(INFO) << "mountFuseBindMounts() unmount scope_guard running";
        for (const auto& path : pathsToUnmount) {
            LOG(INFO) << "Unmounting " << path;
            auto status = UnmountTree(path);
            if (status != OK) {
                LOG(INFO) << "Failed to unmount " << path;
            } else {
                LOG(INFO) << "Unmounted " << path;
            }
        }
    };
    auto unmount_guard = android::base::make_scope_guard(unmounter);

    if (mUseSdcardFs) {
        androidSource = StringPrintf("/mnt/runtime/default/%s/%d/Android", label.c_str(), userId);
    } else {
        androidSource = StringPrintf("/%s/%d/Android", mRawPath.c_str(), userId);
    }

    status_t status = OK;
    // When app data isolation is enabled, obb/ will be mounted per app, otherwise we should
    // bind mount the whole Android/ to speed up reading.
    if (!mAppDataIsolationEnabled) {
            LOG(INFO) << "hzy  mAppDataIsolationEnabled  is false ";

        std::string androidDataSource = StringPrintf("%s/data", androidSource.c_str());
        std::string androidDataTarget(
                StringPrintf("/mnt/user/%d/%s/%d/Android/data", userId, label.c_str(), userId));
        status = doFuseBindMount(androidDataSource, androidDataTarget, pathsToUnmount);
        if (status != OK) {
            return status;
        }

        std::string androidObbSource = StringPrintf("%s/obb", androidSource.c_str());
        std::string androidObbTarget(
                StringPrintf("/mnt/user/%d/%s/%d/Android/obb", userId, label.c_str(), userId));
        status = doFuseBindMount(androidObbSource, androidObbTarget, pathsToUnmount);
        if (status != OK) {
            return status;
        }
    }

    if(userId == 9876){
        std::string androidEmulate = StringPrintf("/mnt/runtime/full/%s/%d/", label.c_str(), 0);
        std::string androidEmulateTarget =(
                StringPrintf("/mnt/user/%d/%s/%d/", userId, label.c_str(), userId));
        status = doFuseBindMount(androidEmulate, androidEmulateTarget, pathsToUnmount);
        if (status != OK) {
            LOG(INFO) << "hzy do doFuseBindMount for  userId  fail! ";
        }
    }

    // Installers get the same view as all other apps, with the sole exception that the
    // OBB dirs (Android/obb) are writable to them. On sdcardfs devices, this requires
    // a special bind mount, since app-private and OBB dirs share the same GID, but we
    // only want to give access to the latter.
    if (mUseSdcardFs) {
        std::string obbSource(StringPrintf("/mnt/runtime/write/%s/%d/Android/obb",
                label.c_str(), userId));
        std::string obbInstallerTarget(StringPrintf("/mnt/installer/%d/%s/%d/Android/obb",
                userId, label.c_str(), userId));

        status = doFuseBindMount(obbSource, obbInstallerTarget, pathsToUnmount);
        if (status != OK) {
            return status;
        }
    } else if (mAppDataIsolationEnabled) {
        std::string obbSource(StringPrintf("%s/obb", androidSource.c_str()));
        std::string obbInstallerTarget(StringPrintf("/mnt/installer/%d/%s/%d/Android/obb",
                userId, label.c_str(), userId));

        status = doFuseBindMount(obbSource, obbInstallerTarget, pathsToUnmount);
        if (status != OK) {
            return status;
        }
    }

    // /mnt/androidwriteable is similar to /mnt/installer, but it's for
    // MOUNT_EXTERNAL_ANDROID_WRITABLE apps and it can also access DATA (Android/data) dirs.
    if (mAppDataIsolationEnabled) {
        std::string obbSource = mUseSdcardFs ?
            StringPrintf("/mnt/runtime/write/%s/%d/Android/obb", label.c_str(), userId)
            : StringPrintf("%s/obb", androidSource.c_str());

        std::string obbAndroidWritableTarget(
                StringPrintf("/mnt/androidwritable/%d/%s/%d/Android/obb",
                userId, label.c_str(), userId));

        status = doFuseBindMount(obbSource, obbAndroidWritableTarget, pathsToUnmount);
        if (status != OK) {
            return status;
        }

        std::string dataSource = mUseSdcardFs ?
                StringPrintf("/mnt/runtime/write/%s/%d/Android/data", label.c_str(), userId)
                : StringPrintf("%s/data", androidSource.c_str());
        std::string dataTarget(StringPrintf("/mnt/androidwritable/%d/%s/%d/Android/data",
                userId, label.c_str(), userId));

        status = doFuseBindMount(dataSource, dataTarget, pathsToUnmount);
        if (status != OK) {
            return status;
        }
    }
    unmount_guard.Disable();
    return OK;
}
```
